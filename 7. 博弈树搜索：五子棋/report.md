# 人工智能实验九 实验报告

| 姓名     |                        |
| -------- | ---------------------- |
| **学号** | **18340057**           |
| **班级** | **18级计算机科学二班** |

## 博弈树搜索

### 1. 算法原理

#### 1.1 博弈树

博弈树针对的是二人零和博弈的问题，二人轮流行动，行动时令自己的优势最大。二人零和博弈有如下特点：

- 确定性：二人的行动有多种选择，但最终的行动是确定的
- 信息完备性：博弈双方知道当前局势（即空间状态）的全部信息
- 零和性：一方的损失等于另一方的收益，二者得分相加恒为零

由以上特点，我们可以构造博弈树。因为信息完备性和确定性，可以用博弈树的每个节点表示一个确定的状态，在动作后得到的新状态作为子节点。对于每个状态都有同一个评价函数来评估双方的得分。因为零和性，一方通过决策使得自身的评价函数尽可能的大，另一方让队手的评价函数尽可能的小。因为二者是轮流行动的，在树的每一层让一方的评价函数取最大和最小交替进行。

由上述的特性，博弈树的搜索过程又被称为minimax搜索。博弈双方行动逐层交替，将评价函数值看做一方的分数，在那一方行动时要让分数尽可能的大，这样的节点被称为Max节点；在另一方行动时要让分数尽可能的小，这样的节点被称为Min节点。

要让一方的下一步采取最优的策略，需要进行树的搜索。在实际问题中，树往往非常大，因此只考虑一定的深度，而不是整个遍历。进行深入搜索时，轮流考虑Max节点和Min节点，每次都采取最优策略，最终得到本步的最优策略。

#### 1.2 Alpha-beta剪枝

通过Alpha-beta剪枝可以对minimax搜索进行剪枝。在博弈树的每个节点保存两个值：$\alpha$表示在该节点能达到的分数的下界，初始化为$-\infin$，$\beta$表示该节点能达到的分数的上界，初始化为$\infin$。

##### 1.2.1 Max节点的剪枝

Max节点的$\beta$值初始化时应该为父节点的$\beta$值。因为Max节点的父节点是Min节点，如果Max节点的$\beta$值大于父节点的$\beta$值，Max节点最终得到的估值必然会大于父节点的$\beta$值，从而表示的状态被不会被父节点选择。

之后，Max节点依次生成子节点。每生成完一个子节点就将子节点的$\alpha$值传递回来。因为子节点为Min节点，会取到分数的最小值，因此必然会取到它的下界$\alpha$，也就是说，Min节点最终的的$\alpha$值就是它的估值。而Max会取子节点中估值最大的，因此，要通过子节点的$\alpha$值来提高自身评分的下界，也就是说，如果子节点的$\alpha$值大于自身的$\alpha$值，则将自身的$\alpha$值更新为更大的那一个。

当$\alpha>\beta$时，该节点的估值一定会大于父节点的估值上界，而父节点是Min节点，是必然不会选择当前节点的。因此所有的子节点可以停止拓展，从而实现了剪枝。

##### 12.2 Min节点的剪枝

Min节点的$\alpha$值初始化时应该为父节点的$\alpha$值。因为Min节点的父节点是Max节点，如果Min节点的$\alpha$值小于父节点的$\alpha$值，Min节点最终得到的估值必然会小于父节点的$\alpha$值，从而表示的状态不会被父节点选择。

之后，Min节点依次生成子节点。每生成完一个子节点就将子节点的$\beta$值传递回来。因为子节点为Max节点，会取到分数的最大值，因此必然会取到它的上界$\beta$，也就是说，Max节点最终的$\beta$值就是它的估值。而Min节点会取子节点中估值最小的，因此要通过子节点的$\beta$值来提高自身评分的上界，也就是说，如果子节点的$\beta$值小于自身的$\beta$值，则将自身的$\beta$值更新为更小的那一个。

当$\alpha>\beta$时，该节点的估值一定会小于父节点的估值下界，而父节点是Max节点，是必然不会选择当前节点的。因此所有的子节点可以停止拓展，从而实现了剪枝。

-------

### 2. 流程图和伪代码

#### 2.1 Minimax搜索的实现

本次实现的是人机交互的五子棋，其中五子棋的AI是通过Minimax搜索决定下棋的位置的。

棋盘为11*11大小，棋子使用列表`chesses`存储，每个元素为一个元组`(x, y, color)`，表示棋子的位置坐标和颜色。

生成Max节点的过程如下：

<img src="pic\\1.png" style="zoom: 67%;" />

生成Min节点的过程如下：

<img src="pic\\2.png" style="zoom: 67%;" />

容易看出，二者具有相当的对称性。Min节点和Max节点的生成和剪枝可以用同一个函数通过递归实现。

```pseudocode
input:type, state, depth, last_a, last_b
/* 输入：节点类型、 当前状态、深度(越大则越浅)、父节点的α和β值 */
output: act, a, b
/* 输出：当前节点取到极值的动作、当前节点的α和β值 */
def NodeSummon(type, state, depth, last_a, last_b):
	/* 生成叶子节点则直接打分 */
	if depth == 0 then return Null, getScore(state),getScore(state)
	/* 依据节点类型初始化α和β值 */
	a = -infin
	b = infin
	if type == Max then b = last_b
	else a = last_a
	/* 遍历每个可行的动作 */
	for eachAct that possible
		newState = changeState(state, eachAct)		/* 依据动作改变当前状态 */
		_, next_a, next_b = NodeSummon(type, chesses, depth-1, a, b)	/* 递归生成子节点 */
		/* 依据节点类型更新α或β值，保存取极值的状态 */
		if type == Max && a<next_a then
        	act = eachAct
        	a = next_a
        if type == Min && b>next_b then
        	act = eachAct
        	b = next_b
        /* 剪枝判断 */
        if a>b then return act, a, b
	end
	return act, a, b
```

需要注意的是，根节点没有父节点，故父节点的α和β值分别设置为负无穷和正无穷。叶子节点不需要向下拓展，而是直接进行打分。打分同时作为该叶子节点的$\alpha$和$\beta$值即可将叶子节点也视作中间节点，方便统一处理。

#### 2.2 分数标准（评价函数的设计）

那么如何给五子棋的棋局打分呢？考虑针对每种颜色进行打分，某一方的分数为：自身颜色的得分减去对手颜色的得分。这样一来就实现了博弈的“零和”条件。五子棋通常是场上连续的相同颜色的子的优势更大，更容易连成五个子，而有时棋手也会有“飞棋”的策略，也就是说，将两部分连续的棋子中间断开一格，当下到这一格将两边连起来时，优势会大幅增加。因此考虑的范围必须必简单的五子棋的“五子”更大。因此这里我每次取六个格子进行评分依据。

对一个棋盘的某种颜色进行打分时，策略如下：依次遍历所有横向、竖向、斜向的连续的六个位置。判断这六个位置的布局，每种布局对应一个分数。以AI为黑色棋子为例，分数具体标准分为如下几个标准：

##### 2.2.1 第一标准：下一步获胜

当AI能够下一步直接制胜时，不要考虑其他任何局势，直接取胜即可。这样一来，取胜的分数就要设置得非常高。同时，要考虑到多层迭代下去，有可能使得连续的子不止五个，应该也给予相当高的分数。

| 棋子状态（下划线表示为空，不列出对称状况） | ●●●●●● | ○●●●●● | _●●●●● |
| ------------------------------------------ | ------ | ------ | ------ |
| 给分                                       | 10000  | 10000  | 10000  |

##### 2.2.2 第二标准：防止敌方下一步获胜

当敌方下一步要获胜且自己不能一步制胜时，需要优先拦截对方的棋，而不是自己造棋势。要注意直接相连的棋和飞棋（隔空的棋）。

| 棋子状态 | ●○○○○● | ○○●○○_ | ○○●○○○ | ○○○○●_ | ○○○●○_ | _○○○●○ | ○○○○●○ | ○○○●○○ |
| -------- | ------ | ------ | ------ | ------ | ------ | ------ | ------ | ------ |
| 给分     | 8000   | 8000   | 8000   | 8000   | 8000   | 8000   | 8000   | 8000   |

总的来说，就是对方再下一个子，就能形成五连或者六连，需要将对方封住。

##### 2.2.3 第三标准：下一步造出必胜棋

如果自己和地方都下一步不能制胜，那么考虑下一步造出必胜棋，即下了之后没有获胜，但可以预期之后就能获胜的棋。也就是两端为空四连。在不同的方向进行联动可以造出其他必胜棋的棋型，这里不进行考虑，只考虑单行/列/斜角的一个方向。

| 棋子状态 | \_●●●●\_ |
| -------- | -------- |
| 给分     | 6000     |

##### 2.2.4 第四标准：破坏对方造必胜棋的条件

如果自己造不出必胜棋，且对方已经出现了活三或者2+1的飞棋形式，两端又为空，则需要防止对方造出活四的必胜棋。

| 棋子状态 | \_●○○○\_ | \_○○●○\_ | _○○\_○● | ●○○\_○_ |
| -------- | -------- | -------- | ------- | ------- |
| 给分     | 4000     | 4000     | 2000    | 2000    |

##### 2.2.5 第五标准：连棋和堵棋

当自己和对手都不能造出必胜棋和一棋制胜，则尽量连自己更多的子、堵对方的连起来的子。标准较杂，不一一列举。

##### 2.2.6 第六标准：其他

若不符合上述所有标准，则直接打分为0。

-----------

### 3. 代码展示

为了实现用户图形界面，我使用`pygame`库来展示。

首先定义一些基本的游戏参数：`trace`为列表，按时间顺序依次记录落棋的位置。`chesses`为所有的棋子，每个元素的格式为`(第几行，第几列，颜色)`，其中颜色为0（纯黑）或255（纯白），初始化为-1，即没有棋。`cross_num`表示棋盘交叉点的个数，即棋盘大小。`depth`为minimax树的大小。

```python
# 游戏参数
trace = []      # 记录下棋的位置
chesses = {}    # 记录所有的落子
cross_num = 11     # 交叉点的个数
depth = 2#int(input())
for x in range(cross_num):
    for y in range(cross_num):
        chesses[(x,y)] = -1
```

首先实现选择先后手。程序会弹出一个如下所示的窗口：

<img src="pic\\3.png" style="zoom: 50%;" />

点击左半边屏幕选择黑棋（先行），右半边为白棋（后行）。选择后，先行方的颜色会被设置为0，另一方为255。该部分基本都是调用`pygame`的接口，与AI核心算法无关，详细代码不进行展示。游戏过程中的画面如下图所示，背景色和格子提前绘制，棋盘上的棋子通过遍历`chesses`列表，一个个将棋子表示出来。

<img src="pic\\4.png" style="zoom:50%;" />

整个游戏过程在一个循环中进行，循环中玩家先下，AI后下。如果是AI先手则在进入循环前让AI先下一步即可。玩家下的过程可以点棋盘上的点，通过坐标的四舍五入下到最近的落子的点上。

```python
x, y = pygame.mouse.get_pos()           # 获取鼠标位置
x = round((x - space) / cross_size)     # 获取到x方向上取整的序号
y = round((y - space) / cross_size)     # 获取到y方向上取整的序号
if x >= 0 and x < cross_num and y >= 0 and y < cross_num and \
chesses[(x,y)] == -1:
    chesses[(x,y)] = player_color  # 将落子加入棋子列表
    trace.append((x,y))
    draw()
    checkWinner()
```

首先获取的为鼠标点击的坐标`(x,y)`，减去边距`space`，除以棋盘格大小`cross_size`，在四舍五入，得到的`(x,y)`就是棋子的落子位置，即第几行第几个。若当前位置`chesses[(x,y)]`为-1，则表示当前位置未落子，因此可以下，则将棋子加入列表中。

`trace`列表按时间顺序记录落子的位置，可以每次将其最后两个元素对应的棋盘上的值改为 -1 实现悔棋。`draw()`函数用于更新画面，`checkWinner()`检查场上是否已经有五连子，若有则分出胜负。

接着由AI下棋，再进行画面打印和检查棋局是否分出胜负：

```python
AIturn()
draw()
checkWinner()
```

AI下棋时，调用博弈树进行minimax搜索（即调用`nextStep`）：

```python
def AIturn():
    score,_,pos = nextStep(chesses, depth, ai_color, float('-inf'), float('inf'))
    print('AI得分：',score)
    chesses[pos] = ai_color
    trace.append(pos)
```

其中，函数`nextStep`的函数原型为：

```
alpha, beta, pos = nextStep(chesses, dep, color, last_alpha, last_beta)
```

函数参数列表的值为：全部的棋子`chesses`、深度`dep`（越大表示越浅，为0时表示叶子节点）、当前执棋方的棋子颜色`color`（通过颜色判断当前节点是Max节点还是Min节点）、父节点的α和β值`last_alpha`、`last_beta`，返回值为当前节点α和β值`alpha`、`beta`。以及取得最值时下棋的位置`pos`。

在`AIturn`函数中首次调用时，将当前状态为初始状态，创建根节点。根节点是AI执棋，因此颜色为`ai_color`，而根节点没有父节点，因此没有α和β值的限制，二者传递的参数分别为负无穷和正无穷。深度默认为2。

具体进行minimax搜索和alpha-beta剪枝的过程都由`nextStep`函数实现：

因为要预测之后的下棋内容，即进一步的状态，因此要将当前状态先拷贝一份副本：

```python
chesses_tmp = chess.copy()
```

然后进行深度判断。当深度为 0 时，表明到达叶子节点，进行评估打分：

```python
# 探索深度到底，进行打分
if dep == 0:
    score = evaluate(chesses_tmp, ai_color) - evaluate(chesses_tmp, player_color)
    return score, score, (-1,-1)
```

返回值为`score, score, (-1,-1)`，因为叶子节点没有α和β值，只有打分结果，将其α和β值都赋值为得分即可。叶子节点不需要进一步下棋来更新状态，因此返回的位置为无效值`(-1, -1)`。这样一来，就将没有α和β值的叶子节点和中间节点统一起来，便于处理。

如果不是叶子节点，则当前节点为中间节点。通过判断是Max节点还是Min节点对α和β值进行初始化：

```python
# 依据节点类型，对alpha和beta初始化
    if color == ai_color:
        alpha = float('-inf')
        beta = last_beta
    else:
        alpha = last_alpha
        beta = float('inf')
```

父节点的α和β值用于给当前节点赋初值。

然后就开始递归地生成子节点：

```python
    # 遍历所有能下的点
    for x in range(cross_num):
        for y in range(cross_num):
            # 排除不太可能的点
            if skipCross(x,y):
                continue
            # 若当前位置没有落子，则生成新节点 
            if chesses_tmp[(x,y)] == -1:
                # 在当前节点落子
                chesses_tmp[(x,y)] = color
                # 递归调用
                next_alpha, next_beta,_ = nextStep(chesses_tmp, dep-1, 255-color, alpha, beta)
                # 撤销当前节点的落子
                chesses_tmp[(x,y)] = -1
                # 依据节点类型更新α和β值
                if color == ai_color and alpha < next_beta:
                    alpha = next_beta
                    pos = (x,y)
                if color == player_color and beta > next_alpha:
                    beta = next_alpha
                    pos = (x,y)
                # α-β 剪枝
                if beta < alpha:
                    return alpha, beta, pos
    return alpha, beta, pos
```

遍历棋盘上所有的点，首先进入`skipCross(x,y)`函数判断。若当前位置周围（8领域）没有其他落子，该节点大概率不会是最优的落子位置，因此直接跳过。这是从下五子棋角度来说的直观的剪枝。可以一定程度提高搜索速度，特别是刚开局不久。然后若当前位置能落子，则进行落子生成新的状态，递归调用`nextStep`生成子节点。

得到子节点的返回值后，依据子节点的α和β值与自身节点的类型（Max或Min）来进行α和β值的更新。若需要更新则说明当前位置为最优的位置，所以同时也要将位置`pos`进行保存和返回，便于之后确定决策的行动。

在任何时候，若α值大于β，则需要进行剪枝。函数直接返回即可。如果不需要剪枝，出循环后也返回。

当`nextStep`函数递归完成后，在`AIturn`函数得到的`pos`值即为最大化根节点的落子位置，选择该位置即可。

叶子节点的具体打分由`evaluate`函数进行：

```python
def evaluate(chess, color):
    score = 0
    # 横着的部分
    for x in range(cross_num):
        for y in range(cross_num-5):
            score += getScore(color, (chess[(x,y)], chess[(x,y+1)], \
                      chess[(x,y+2)], chess[(x,y+3)], chess[(x,y+4)], chess[(x,y+5)]))
    # 竖着的部分
    for x in range(cross_num-5):
        for y in range(cross_num):
            score += getScore(color, (chess[(x,y)], chess[(x+1,y)], \
                      chess[(x+2,y)], chess[(x+3,y)], chess[(x+4,y)], chess[(x+5,y)]))
    # 左上到右下
    for x in range(cross_num-5):
        for y in range(cross_num-5):
            score += getScore(color, (chess[(x,y)], chess[(x+1,y+1)], \
                      chess[(x+2,y+2)], chess[(x+3,y+3)], chess[(x+4,y+4)], chess[(x+5,y+5)]))
    # 右上到左下
    for x in range(cross_num-5):
        for y in range(cross_num-5):
            score += getScore(color, (chess[(x+5,y)], chess[(x+4,y+1)], \
                      chess[(x+3,y+2)], chess[(x+2,y+3)], chess[(x+1,y+4)], chess[(x,y+5)]))
    return score
```

`evaluate`函数将取出棋盘中所有的横向、竖向、斜向的六个连续位置的落子状况传给`getScore`函数。`getScore`函数为单独的六个连续位置的落子情况进行打分。将所有位置的分数进行加和就得到了当前指定颜色的总分。

`getScore`函数的部分如下：

```python
def getScore(color ,chess):
    # 优先直接取得胜利
    if chess == (color, color, color, color, color, color)\
    or chess == (color, color, color, color, color, 255 - color) \
    or chess == (255-color, color, color, color, color, color)\
    or chess == (-1, color, color, color, color, color) or \
    chess == (color, color, color, color, color, -1):
        return 10000
    
    ... ...
    
    return 0
```

就是通过给出的连续六个位置的情况进行打分。如果不符合所有考虑的排列状况则分数为0。具体的打分细则见之前的描述，分数的高低分成几个等级：

- 下一步能**直接**取得胜利，分数极高
- 阻止对手下一步**直接**取得胜利，分数很高
- 下一步确保**之后**能取得胜利，分数较高
- 阻止对手下一步能确保**之后**对手胜利，分数较低
- 尽量让自己有更多连续的子，防止对手有更多连续的子，分数很低
- 其他情况，分数最低

玩家和AI落子后都会有`checkWinner()`函数进行检查，和`evaluate`函数类似，它会取出每个连续的五个位置，若这五个位置的棋的颜色完全相同，则可以决出赢家。它会将位置记录下来传递给之前的`draw`函数，画出棋局的同时额外画出判定获胜的五个子。

另外，通过列表`trace`记录下的每一步棋，可以通过删除`trace`列表中的最后两个元素与它们对应的棋盘位置的棋子，以此实现悔棋的功能。按任意键进行悔棋的代码在下棋过程中的循环实现，代码为：

```python
if event.type == pygame.KEYDOWN:
    key = pygame.key.get_pressed()
    # 按空格则强制刷新棋盘
    if key[pygame.K_SPACE]:
        draw()
        continue
    # 进行悔棋
    # 删除最后两步的落子（玩家和AI各一步）
    chesses[trace[-1]] = -1
    chesses[trace[-2]] = -1
    # 删除trace的最后两步
    trace = trace[:-2]
    draw()
```

在构造博弈树的搜索深度较深时，程序会短暂的卡住。恢复之后AI进行下棋，参数能正常更新但画面不会刷新。这可能是`pygame`的bug所致。我额外设计了上面按空格重新调用`draw`函数进行画面更新的功能，以此解决这个问题。

-------------

### 4. 实验结果及分析

依据实验题目要求，棋盘落子情况初始化为下：

<img src="pic\\5.png" style="zoom:33%;" />

下面尝试玩家执黑棋先行。一回合之后结果如下：

<img src="pic\\6.png" style="zoom:33%;" />

我尝试做了一个活三（三个连续的黑子，两端为空），AI下了右下的白子。这看上去的确是合理的。AI落子的位置一方面堵住了玩家的活三，同时AI下的位置上两格有一个白子，便于它之后连接成活三。

第二回合结果如下：

<img src="pic\\7.png" style="zoom:33%;" />

我连成一个一端有空的四个连起来的黑子，如此一来，如果AI不拦截的话我下一步就能直接胜利。可以看到，AI的确拦截了。

第三回合：

<img src="pic\\8.png" style="zoom:33%;" />

AI优先做了一个活三。

第四回合：

<img src="pic\\9.png" style="zoom:33%;" />

第五回合：

<img src="pic\\10.png" style="zoom:33%;" />

可以看到，在第五回合我落子后，如果在中点的左上角再下一子，连成两个活三，就必胜了，因此AI必须提前拦住我。它选择了我落子的下方进行落子，这样一来即破坏了我的两个连续的活三，又能制造一个自己的活三。

这五回合AI的得分分别为：

![](pic\\11.png)

第一回合我有一个活三，因此拉低了AI的得分。而AI通过堵我的活三得到了一些分。第二回合我做出了连续的四个子，AI要马上拦截连续的四个子防止我获胜，于是按照设定，拦截可以拿到很高的分。在第二回合通过拦截，AI的分数急剧提高了。之后的几回合没有出现“马上要获胜”的情况，因此分数没有急剧上升。而被堵住的连续的四个黑子一直都在场上，会重复计算分数，因此分数会一直在较高的水平。

下面尝试让AI先手，并让AI取得胜利。

第一步AI下棋：

<img src="pic\\12.png" style="zoom:33%;" />

第二回合：

<img src="pic\\13.png" style="zoom:33%;" />

我造出了三个活二，因此AI选择进行拦截。

第三回合：

<img src="pic\\14.png" style="zoom:33%;" />

我造了一个2+1的飞棋，AI在拦截飞棋的同时又去拦截上方的活二。

第四回合：

<img src="pic\\15.png" style="zoom:33%;" />

我造了2+2的飞棋，AI必须进行拦截，否则我将胜利。AI的确拦截了。

第五回合：

<img src="pic\\16.png" style="zoom:33%;" />

AI有个活三，我故意不去拦截让AI造出了活四。

第六回合：

<img src="pic\\17.png" style="zoom:33%;" />

我造了个活三，AI优先取得胜利而不是来拦截我的活三。

这五步AI的得分为：

![](pic\\18.png)

第二步我一次性造了三个活二，而在评价函数中活二可以出现在多个六个相邻位置的排列中，因此AI的分数骤降。第三个回合我造了2+1的飞棋，如果AI不拦截则会输，所以拦截的分数很高。AI拦截了，分数也提高了很多。之后我连成了四个子，AI不拦截则会输。拦截后AI又提高了很多分。第五回合AI造了活四，得了很高的分，最后一步取得胜利，直接取得胜利的得分比拦截活三高得多，因此AI选择直接取胜而不是拦截我的活三。